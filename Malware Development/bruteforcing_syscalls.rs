use ntapi::ntobapi::DUPLICATE_SAME_ACCESS;
use process::myntopenprocess;
use winapi::um::{errhandlingapi::GetLastError, memoryapi::{VirtualAlloc, VirtualFree, WriteProcessMemory}, processthreadsapi::{OpenProcess, GetCurrentProcessId, OpenProcessToken, GetCurrentProcess}, winnt::{PROCESS_QUERY_LIMITED_INFORMATION, TOKEN_QUERY, TOKEN_DUPLICATE, PROCESS_ALL_ACCESS, PROCESS_QUERY_INFORMATION, TOKEN_ASSIGN_PRIMARY, TOKEN_ADJUST_PRIVILEGES, PROCESS_DUP_HANDLE, TOKEN_ALL_ACCESS, TOKEN_ADJUST_DEFAULT, TOKEN_ADJUST_SESSIONID}};
use winapi::ctypes::*;
use winapi::um::handleapi::*;
use winapi::shared::ntdef::{POBJECT_ATTRIBUTES,NTSTATUS,OBJECT_ATTRIBUTES};

use ntapi::ntapi_base::*;
use winapi::um::winnt::*;
use std::arch::asm;
use std::arch::global_asm;




fn main(){

  unsafe{




            //let mut final1:Vec<u8> = Vec::new();
            let mut v = Vec::from([0x49u8, 0x89, 0xCA, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3]);
           /*for i in 1..1000{
            std::ptr::write((v.as_mut_ptr() as usize + 4)
            as *mut u32, i);
            /*for j in &v{
                final1.push(*j);
            }
            println!("{:x?}",v);*/
           }*/
           
           let base = VirtualAlloc(std::ptr::null_mut(), 
            v.len(), 
            MEM_RESERVE|MEM_COMMIT, 
            PAGE_EXECUTE_READWRITE);

            let mut byteswritten = 0;
            WriteProcessMemory(GetCurrentProcess(), 
            base, 
            v.as_ptr() as *const c_void, 
            v.len(), &mut byteswritten);

           for i  in 1..200{
                std::ptr::write(
                (base as usize + 4) as *mut u32 , 
                i as u32);

                let f1 = std::mem::transmute::<*mut c_void,
                fn (
                      PHANDLE, 
                      ACCESS_MASK, 
                     &OBJECT_ATTRIBUTES, 
                           &CLIENT_ID
                ) -> NTSTATUS
                >((base as usize ) as *mut c_void);

                
               
    
                let mut phandle = 0 as *mut c_void;
                let mut oa = std::mem::zeroed::<OBJECT_ATTRIBUTES>();
                oa.Length = std::mem::size_of::<OBJECT_ATTRIBUTES>() as u32;
                let mut clientid = std::mem::zeroed::<CLIENT_ID>();
                clientid.UniqueProcess = GetCurrentProcessId() as *mut c_void;
                let ntstatus = f1(&mut phandle,
                    PROCESS_ALL_ACCESS,
                    &mut oa,
                    &mut clientid);
    

                    

                    // NtOpenProcess returns 0 on success
                if ntstatus == 0{
                    println!("syscall number: 0x{:x?}",
                    std::ptr::read((base as usize +4 ) as *const u32) );
                    println!("ntstatus: {:x?}",ntstatus);
                    println!("phandle: {:x?}",phandle);
                    CloseHandle(phandle);
                    break;
                }
    
           }
           VirtualFree(base, 0, MEM_RELEASE);
           return ();

       

            #[link_section=".text"]
            static buf:[u8;33] =[ 
                // mov r10,rcx
                // mov eax, 0x25
                // syscall
                // ret
                0x49, 0x89, 0xCA, 0xB8, 0x25, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3,
            // mov r10,rcx
                // mov eax, 0x26
                // syscall
                // ret
            
            0x49, 0x89, 0xCA, 0xB8, 0x26, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3,
            0x49, 0x89, 0xCA, 0xB8, 0x27, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3];


}
