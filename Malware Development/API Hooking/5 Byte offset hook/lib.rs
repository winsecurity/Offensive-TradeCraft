
use winapi::um::processthreadsapi::{GetCurrentProcess, GetCurrentProcessId};
use winapi::um::winnt::{DLL_THREAD_ATTACH, PAGE_EXECUTE_READWRITE};
use winapi::um::winuser::*;
use winapi::{ctypes::*, um::winnt::DLL_PROCESS_ATTACH};
use winapi::shared::minwindef::*;
use winapi::um::libloaderapi::*;
use winapi::shared::ntdef::*;
use winapi::shared::windef::*;
use winapi::um::memoryapi::*;

use crate::peparser::{getloadeddlls, getprocessbaseaddress};
pub mod peparser;

pub fn ReadStringFromMemory(prochandle: *mut c_void, base: *const c_void) -> String {
    unsafe {
        let mut i: isize = 0;
        let mut s = String::new();
        loop {
            let mut a: [u8; 1] = [0];
            ReadProcessMemory(
                prochandle,
                (base as isize + i) as *const c_void,
                a.as_mut_ptr() as *mut c_void,
                1,
                std::ptr::null_mut(),
            );

            if a[0] == 0 || i == 50 {
                return s;
            }
            s.push(a[0] as char);
            i += 1;
        }
    }
}


#[no_mangle]
pub unsafe extern "C" fn helloworld(){
    unsafe{

       MessageBoxA(std::ptr::null_mut(), 
       "hi\0".as_bytes().as_ptr() as *const i8, 
       "hi\0".as_bytes().as_ptr() as *const i8, 0);

    }
}



#[no_mangle]
pub  unsafe extern "C" fn maliciousmsgbox(hWnd: HWND,
    lpText: LPCSTR,
    lpCaption: LPCSTR,
    uType: UINT) -> i32{
    unsafe{

        // restoring those 5 bytes
        let mut byteswritten = 0;
        WriteProcessMemory(GetCurrentProcess(), 
        msgboxaddr as *mut c_void, 
        ogbytes.as_ptr() as *const c_void, 
        ogbytes.len(), &mut byteswritten);


        println!("lptext: {}",ReadStringFromMemory(GetCurrentProcess(), lpText as *const c_void));
    
        return MessageBoxA(hWnd, "malicious\0".as_bytes().as_ptr() as *const i8,
         lpCaption, uType);
    }
}


static mut ogbytes:[u8;5] = [0u8;5];
static mut msgboxaddr: usize = 0;

#[no_mangle]
pub  fn hook(){
    unsafe{
        let mut iataddr = 0 as usize;
        let procbase = getprocessbaseaddress(GetCurrentProcess());
        let pe = peparser::peparser::parsefrommemory(GetCurrentProcess(), procbase as *const c_void).unwrap();
        let imports = pe.getimports().unwrap();
        //println!("imports: {:x?}",imports);
        for i in 0..imports.len(){
            for (k,v) in &imports[i]{
                if &*k.to_lowercase() == "user32.dll"{
                    for (k1,v1) in v{
                        if &*k1.to_lowercase() == "messageboxa"{
                            msgboxaddr = v1[1];
                            iataddr = v1[0];
                        }
                    }
                }
            }
        }

        let mut maladdr = 0;
       let dlls = getloadeddlls(GetCurrentProcessId());
        for (k,v ) in &dlls{
            if &*k.to_lowercase() == "myhooking.dll"{
                let dllbase = *v;
                let dll = peparser::peparser::parsefrommemory(GetCurrentProcess(), dllbase as *const c_void).unwrap();
                let exports = dll.getexports().unwrap();
                for (k2,v2) in &exports{
                    if &*k2.to_lowercase() =="maliciousmsgbox"{
                       
                        maladdr = dllbase + *v2;
                        println!("msgboxaddr: {:x?}",msgboxaddr);
                        println!("maliciousmsgbox: {:x?}",maladdr);
                    }
                }
            }
        }


        //let dllhandle = GetModuleHandleA("user32.dll\0".as_bytes().as_ptr() as *const i8);
        //msgboxaddr = GetProcAddress(dllhandle, "MessageBoxA\0".as_bytes().as_ptr() as *const i8) as usize;

        
        let offset = maladdr as usize - (msgboxaddr as usize+5);
        
        let mut byteswritten: usize = 0;

        /*let res = WriteProcessMemory(GetCurrentProcess(), 
        (procbase + iataddr) as *mut c_void, 
        maladdr.to_ne_bytes().as_ptr() as *const c_void, 
        8, 
        &mut byteswritten);
        println!("writeprocessmemory res: {}",res);

        return ();*/

        let mut bytesread = 0;
        ReadProcessMemory(GetCurrentProcess(), 
        msgboxaddr as *const c_void, 
        ogbytes.as_mut_ptr() as *mut c_void, 
        ogbytes.len(), &mut bytesread);
        
        
        println!("msgboxaddr: {:x?}",msgboxaddr);
        println!("our hooked func: {:x?}",maladdr as usize);
        println!("offset: {:x?}",offset);


        let mut jmp:Vec<u8> = vec![0;5];
        jmp[0] = (0xe9); // 0xe9 for jmp
        WriteProcessMemory(GetCurrentProcess(), 
        (jmp.as_mut_ptr() as usize + 1) as *mut c_void, 
        offset.to_ne_bytes().as_ptr() as *const c_void, 
        4, &mut byteswritten );

        println!("jmp: {:x?}",jmp);

        /*let mut oldprotect = 0;
        let res = VirtualProtect(msgboxaddr as *mut c_void, 
            5, PAGE_EXECUTE_READWRITE, &mut oldprotect);
        
        println!("virtualprotect res: {}",res);*/

        
        let res = WriteProcessMemory(GetCurrentProcess(), 
        msgboxaddr as *mut c_void, 
        jmp.as_ptr() as *const c_void, 
        5, &mut byteswritten);

        println!("writeprocessmemory res: {}",res);

        
    }
}

#[no_mangle]
pub unsafe extern "stdcall" fn DllMain(
    hinstance: HINSTANCE,
    reason: u32,
    reserved: *mut c_void
) -> bool{

    
    match reason{
        DLL_PROCESS_ATTACH =>{
            hook();
            
        }
        DLL_THREAD_ATTACH=> hook(),
        _ => ()
    }

    return true;


}
