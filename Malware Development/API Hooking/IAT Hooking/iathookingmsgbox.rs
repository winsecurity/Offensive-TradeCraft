use std::fmt::Write;

use winapi::um::processthreadsapi::{GetCurrentProcess, GetCurrentProcessId};
use winapi::um::winnt::{DLL_THREAD_ATTACH, PAGE_EXECUTE_READWRITE, PAGE_READWRITE};
use winapi::um::winuser::*;
use winapi::{ctypes::*, um::winnt::DLL_PROCESS_ATTACH};
use winapi::shared::minwindef::*;
use winapi::um::libloaderapi::*;
use winapi::shared::ntdef::*;
use winapi::shared::windef::*;
use winapi::um::memoryapi::*;

use crate::peparser::{getloadeddlls, getprocessbaseaddress};
pub mod peparser;

pub fn ReadStringFromMemory(prochandle: *mut c_void, base: *const c_void) -> String {
    unsafe {
        let mut i: isize = 0;
        let mut s = String::new();
        loop {
            let mut a: [u8; 1] = [0];
            ReadProcessMemory(
                prochandle,
                (base as isize + i) as *const c_void,
                a.as_mut_ptr() as *mut c_void,
                1,
                std::ptr::null_mut(),
            );

            if a[0] == 0 || i == 50 {
                return s;
            }
            s.push(a[0] as char);
            i += 1;
        }
    }
}



#[no_mangle]
pub  unsafe extern "C" fn maliciousmsgbox2(hWnd: HWND,
    lpText: LPCSTR,
    lpCaption: LPCSTR,
    uType: UINT) -> i32{
    unsafe{

        let mut byteswritten: usize = 0;
        // restoring the msgbox address at first thunk

        WriteProcessMemory(GetCurrentProcess(), 
        firstthunk as *mut c_void,
        msgboxaddr.to_ne_bytes().as_ptr() as *const c_void , 
        8, &mut byteswritten);

        
        println!("parameters passed");
        println!("lptext: {}",ReadStringFromMemory(GetCurrentProcess(), lpText as *const c_void));
        

        return MessageBoxA(hWnd, "malicious\0".as_bytes().as_ptr() as *const i8,
         lpCaption, uType);
    }
}


static mut ogbytes:[u8;5] = [0u8;5];
static mut msgboxaddr: usize = 0;
static mut firstthunk:usize = 0;





#[no_mangle]
pub  fn iathook(srcdll:&str, srcfunc:&str,dstdll:&str,dstfunc:&str){
    unsafe{
        
        let mut iataddr = 0 as usize;
        let procbase = getprocessbaseaddress(GetCurrentProcess());
        //println!("procbase: {:x?}",procbase);
        //let loadeddlls = getloadeddlls(GetCurrentProcessId());
        //println!("loaded dlls: {:x?}",loadeddlls);
        let pe = peparser::peparser::parsefrommemory(GetCurrentProcess(), procbase as *const c_void).unwrap();
        let imports = pe.getimports().unwrap();
        //println!("imports: {:x?}",imports);
        for i in 0..imports.len(){
            for (k,v) in &imports[i]{
                if &*k.to_lowercase() == srcdll{
                    for (k1,v1) in v{
                        if &*k1.to_lowercase() == srcfunc{
                            msgboxaddr = v1[1];
                            iataddr = v1[0];
                            //println!("firstthunk: {:x?}",iataddr);
                            //println!("msgboxaddr: {:x?}",msgboxaddr);
                        }
                    }
                }
            }
        }


        firstthunk = procbase + iataddr;
        let mut maladdr = 0;
        let mut dllbase = 0;
       let dlls = getloadeddlls(GetCurrentProcessId());
        for (k,v ) in &dlls{
            if &*k.to_lowercase() == dstdll{
                 dllbase = *v;
                let dll = peparser::peparser::parsefrommemory(GetCurrentProcess(), dllbase as *const c_void).unwrap();
                let exports = dll.getexports().unwrap();
                for (k2,v2) in &exports{
                    if &*k2.to_lowercase() ==dstfunc{
                       
                        maladdr = dllbase + *v2;
                       // println!("msgboxaddr: {:x?}",msgboxaddr);
                       // println!("maliciousmsgbox: {:x?}",maladdr);
                    }
                }
            }
        }

        let mut test1=[0u8;8];
        let mut byteswritten: usize = 0;


        ReadProcessMemory(GetCurrentProcess(), 
        (procbase + iataddr) as *mut c_void,
        test1.as_mut_ptr() as *mut c_void , 
        8, &mut byteswritten);

        
        //let dllhandle = GetModuleHandleA("user32.dll\0".as_bytes().as_ptr() as *const i8);
        //msgboxaddr = GetProcAddress(dllhandle, "MessageBoxA\0".as_bytes().as_ptr() as *const i8) as usize;

        let mut oldprotect = 0;
        let res = VirtualProtect(
        (procbase + iataddr) as *mut c_void,
         8, 
         PAGE_READWRITE, 
        &mut oldprotect);
       
        
       
        let res = WriteProcessMemory(GetCurrentProcess(), 
        (procbase + iataddr) as *mut c_void, 
        maladdr.to_ne_bytes().as_ptr() as *const c_void, 
        8, 
        &mut byteswritten);
        
        

       
        
    }
}



#[no_mangle]
pub unsafe extern "stdcall" fn DllMain(
    hinstance: HINSTANCE,
    reason: u32,
    reserved: *mut c_void
) -> bool{

    
    match reason{
        DLL_PROCESS_ATTACH =>{
            iathook("user32.dll","messageboxa",
                "myhooking.dll","maliciousmsgbox2");
            
        }
        DLL_THREAD_ATTACH=> hook(),
        _ => ()
    }

    return true;


}
