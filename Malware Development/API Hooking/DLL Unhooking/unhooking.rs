
pub fn unhookdllfromfile(prochandle:*mut c_void,pid:u32, 
    filepath:&str,dllinprocess:&str){
    unsafe{

        let mut dllbase = 0;
            let dlls = getloadeddlls(pid);
            for (k,v) in &dlls{
                if &*k.to_lowercase().to_string()==dllinprocess.to_lowercase(){
                    dllbase = *v;
                }
            }


           // let ntdllhandle =  GetModuleHandleA("ntdll.dll\0".as_bytes().as_ptr() as *const i8);
            let ourpe = peparser::parsefrommemory(prochandle, dllbase as *const c_void).unwrap();
            let dllsections = ourpe.getsectionheaders();



            let mut originaltext = Vec::new();
            let pe = peparser::parsefromfile(filepath).unwrap();
            let sections =  pe.getsectionheaders();
            for i in 0..sections.len(){
                let sectionname = ReadStringFromMemory(GetCurrentProcess(), sections[i].Name.as_ptr() as *const c_void).trim_end_matches("\0").to_string();
                if sectionname.to_lowercase().to_string()==".text"{
                    let contentsbase = pe.filecontents.as_ptr() as usize +  sections[i].PointerToRawData as usize;
                    originaltext = vec![0u8;(*sections[i].Misc.VirtualSize()) as usize];
                    let mut bytesread = 0;
                    ReadProcessMemory(GetCurrentProcess(), 
                    contentsbase as *mut c_void, 
                    originaltext.as_mut_ptr() as *mut c_void, 
                    originaltext.len(), 
                    &mut bytesread);
                
                }

            }

            let mut textsection = std::mem::zeroed::<IMAGE_SECTION_HEADER>();
            for i in 0..dllsections.len(){
                let sectionname = ReadStringFromMemory(GetCurrentProcess(), dllsections[i].Name.as_ptr() as *const c_void).trim_end_matches("\0").to_string();
                if sectionname.to_lowercase().to_string()==".text"{
                    textsection = dllsections[i].clone();
                    let targettextaddr= dllbase + dllsections[i].VirtualAddress as usize;

                    let mut previoustext = vec![0u8;(*dllsections[i].Misc.VirtualSize()) as usize];

                    let mut bytesread = 0;
                    ReadProcessMemory(prochandle, 
                    targettextaddr as *const c_void, 
                    previoustext.as_mut_ptr() as *mut c_void, 
                    previoustext.len(), 
                    &mut bytesread);

                    println!("{:x?}",previoustext[9]);

                    let mut oldprotect = 0;
                    VirtualProtectEx(prochandle, 
                    targettextaddr as *mut c_void, 
                    *dllsections[i].Misc.VirtualSize() as usize, 
                    PAGE_EXECUTE_READWRITE, &mut oldprotect);
                
                    let mut byteswritten = 0;
                    WriteProcessMemory(prochandle, 
                    targettextaddr as *mut c_void, 
                    originaltext.as_ptr() as *const c_void, 
                    originaltext.len() , 
                    &mut byteswritten);

                    
                    VirtualProtectEx(prochandle, 
                    targettextaddr as *mut c_void, 
                    *dllsections[i].Misc.VirtualSize() as usize, 
                    oldprotect, &mut oldprotect);
                

                    let mut bytesread = 0;
                    ReadProcessMemory(prochandle, 
                    targettextaddr as *const c_void, 
                    previoustext.as_mut_ptr() as *mut c_void, 
                    previoustext.len(), 
                    &mut bytesread);

                    println!("{:x?}",previoustext[9]);

                }

            }


            let delta = (dllbase) - pe.getntheader().OptionalHeader.ImageBase as usize;
            let relocations = pe.getbaserelocations().unwrap();
            for i in 0..relocations.len(){
                for (pagerva,offset) in &relocations[i]{

                    if ((*pagerva) as usize>=(textsection.VirtualAddress as usize + (*textsection.Misc.VirtualSize()) as usize)) ||
                        ((*pagerva) as usize)<(textsection.VirtualAddress as usize) {
                        continue;
                    }

                    let mut oldvalue = vec![0u8;8];
                    let mut bytesread = 0;
                    ReadProcessMemory(prochandle, 
                    (dllbase + *pagerva as usize + *offset as usize) as *const c_void, 
                    oldvalue.as_mut_ptr() as *mut c_void, 
                    8, 
                    &mut bytesread);
                    println!("{:x?}",oldvalue);

                    let oldvalue = u64::from_ne_bytes(oldvalue.try_into().unwrap());
                    let newvalue = delta + oldvalue as usize;

                    let mut oldprotect = 0 ;
                    VirtualProtectEx(prochandle, 
                    (dllbase + *pagerva as usize + *offset as usize) as *mut c_void, 
                    8, PAGE_READWRITE, &mut oldprotect);

                    WriteProcessMemory(prochandle, 
                    (dllbase + *pagerva as usize + *offset as usize) as *mut c_void,
                     newvalue.to_ne_bytes().as_ptr() as *const c_void, 
                     8, &mut bytesread);

                     VirtualProtectEx(prochandle, 
                     (dllbase + *pagerva as usize + *offset as usize) as *mut c_void, 
                     8, oldprotect, &mut oldprotect);
 
                }
            }



    }
}



pub fn unhookdllfrommemory(prochandle:*mut c_void,pid:u32,
     desthandle:*mut c_void,destdlladdress:*const c_void,dllinprocess:&str){
    unsafe{

        let mut dllbase = 0;
            let dlls = getloadeddlls(pid);
            for (k,v) in &dlls{
                if &*k.to_lowercase().to_string()==dllinprocess.to_lowercase(){
                    dllbase = *v;
                }
            }


           // let ntdllhandle =  GetModuleHandleA("ntdll.dll\0".as_bytes().as_ptr() as *const i8);
            let ourpe = peparser::parsefrommemory(prochandle, dllbase as *const c_void).unwrap();
            let dllsections = ourpe.getsectionheaders();


            let pe = peparser::parsefrommemory(desthandle, destdlladdress).unwrap();

            let mut originaltext = Vec::new();
            //let pe = peparser::parsefromfile(filepath).unwrap();
            let sections =  pe.getsectionheaders();
            for i in 0..sections.len(){
                let sectionname = ReadStringFromMemory(GetCurrentProcess(), sections[i].Name.as_ptr() as *const c_void).trim_end_matches("\0").to_string();
                if sectionname.to_lowercase().to_string()==".text"{
                    let contentsbase = pe.memorycontents.as_ptr() as usize +  sections[i].PointerToRawData as usize;
                    originaltext = vec![0u8;(*sections[i].Misc.VirtualSize()) as usize];
                    let mut bytesread = 0;
                    ReadProcessMemory(GetCurrentProcess(), 
                    contentsbase as *mut c_void, 
                    originaltext.as_mut_ptr() as *mut c_void, 
                    originaltext.len(), 
                    &mut bytesread);
                
                }

            }

            let mut textsection = std::mem::zeroed::<IMAGE_SECTION_HEADER>();
            for i in 0..dllsections.len(){
                let sectionname = ReadStringFromMemory(GetCurrentProcess(), dllsections[i].Name.as_ptr() as *const c_void).trim_end_matches("\0").to_string();
                if sectionname.to_lowercase().to_string()==".text"{
                    textsection = dllsections[i].clone();
                    let targettextaddr= dllbase + dllsections[i].VirtualAddress as usize;

                    let mut previoustext = vec![0u8;(*dllsections[i].Misc.VirtualSize()) as usize];

                    let mut bytesread = 0;
                    ReadProcessMemory(prochandle, 
                    targettextaddr as *const c_void, 
                    previoustext.as_mut_ptr() as *mut c_void, 
                    previoustext.len(), 
                    &mut bytesread);

                    println!("{:x?}",previoustext[9]);

                    let mut oldprotect = 0;
                    VirtualProtectEx(prochandle, 
                    targettextaddr as *mut c_void, 
                    *dllsections[i].Misc.VirtualSize() as usize, 
                    PAGE_EXECUTE_READWRITE, &mut oldprotect);
                
                    let mut byteswritten = 0;
                    WriteProcessMemory(prochandle, 
                    targettextaddr as *mut c_void, 
                    originaltext.as_ptr() as *const c_void, 
                    originaltext.len() , 
                    &mut byteswritten);

                    
                    VirtualProtectEx(prochandle, 
                    targettextaddr as *mut c_void, 
                    *dllsections[i].Misc.VirtualSize() as usize, 
                    oldprotect, &mut oldprotect);
                

                    let mut bytesread = 0;
                    ReadProcessMemory(prochandle, 
                    targettextaddr as *const c_void, 
                    previoustext.as_mut_ptr() as *mut c_void, 
                    previoustext.len(), 
                    &mut bytesread);

                    println!("{:x?}",previoustext[9]);

                }

            }


            let delta = (dllbase) - pe.getntheader().OptionalHeader.ImageBase as usize;
            let relocations = pe.getbaserelocations().unwrap();
            for i in 0..relocations.len(){
                for (pagerva,offset) in &relocations[i]{

                    if ((*pagerva) as usize>=(textsection.VirtualAddress as usize + (*textsection.Misc.VirtualSize()) as usize)) ||
                        ((*pagerva) as usize)<(textsection.VirtualAddress as usize) {
                        continue;
                    }

                    let mut oldvalue = vec![0u8;8];
                    let mut bytesread = 0;
                    ReadProcessMemory(prochandle, 
                    (dllbase + *pagerva as usize + *offset as usize) as *const c_void, 
                    oldvalue.as_mut_ptr() as *mut c_void, 
                    8, 
                    &mut bytesread);
                    println!("{:x?}",oldvalue);

                    let oldvalue = u64::from_ne_bytes(oldvalue.try_into().unwrap());
                    let newvalue = delta + oldvalue as usize;

                    let mut oldprotect = 0 ;
                    VirtualProtectEx(prochandle, 
                    (dllbase + *pagerva as usize + *offset as usize) as *mut c_void, 
                    8, PAGE_READWRITE, &mut oldprotect);

                    WriteProcessMemory(prochandle, 
                    (dllbase + *pagerva as usize + *offset as usize) as *mut c_void,
                     newvalue.to_ne_bytes().as_ptr() as *const c_void, 
                     8, &mut bytesread);

                     VirtualProtectEx(prochandle, 
                     (dllbase + *pagerva as usize + *offset as usize) as *mut c_void, 
                     8, oldprotect, &mut oldprotect);
 
                }
            }



    }
}


